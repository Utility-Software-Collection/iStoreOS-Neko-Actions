name: 💿 St1_Build-Rootfs-release
on:
  workflow_dispatch:
    inputs:
      network_settings:
        description: "请选择初始网络配置"
        required: true
        default: 'dhcp'
        type: choice
        options:
          - 'static'
          - 'dhcp'
      ipaddr:
        description: '请输入管理IP（静态地址时必填）'
        required: true
        default: '192.168.5.88'
      gateway:
        description: '请输入默认网关（静态地址时必填）'
        required: true
        default: '192.168.5.1'
      include_docker:
        description: "是否集成Docker插件"
        required: true
        default: 'yes'
        type: choice
        options:
          - 'yes'
          - 'no'
      include_nikki:
        description: "是否集成 OpenWrt-nikki (透明代理插件)"
        required: true
        default: 'no' 
        type: choice
        options:
          - 'yes'
          - 'no'

      include_openclash:
        description: "是否集成 OpenClash 代理插件"
        required: true
        default: 'no'
        type: choice
        options:
          - 'yes'
          - 'no'

env:
  VERSION: 24.10.3

jobs:
  build:
    runs-on: ubuntu-22.04
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: ⚙️ 设置可执行权限
      run: | 
        chmod +x arm64/build24.sh
        chmod +x shell/*.sh

    - name: ⚙️ 设置IP和网关
      run: |
        echo "当前网络配置路径"
        CONFIG_PATH="./files/etc/uci-defaults/99-custom.sh"
        echo $CONFIG_PATH
        if [ "${{ inputs.network_settings }}" = "static" ]; then
           echo "删除网络设置-dhcp"
           sed -i '44,105d' "$CONFIG_PATH"
           echo "替换默认配置"
           sed -i "/ipaddr/s/192.168.5.88/${{ inputs.ipaddr }}/g" "$CONFIG_PATH"
           sed -i "/gateway/s/192.168.5.1/${{ inputs.gateway }}/g" "$CONFIG_PATH"
        else
           echo "删除网络设置-static"
           sed -i '36,42d' "$CONFIG_PATH"
        fi
        echo "输出配置"
        cat $CONFIG_PATH

    - name: ⏬ 安装依赖
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential libncurses5-dev zstd curl unzip tree

    - name: ⏬ 下载 ImageBuilder
      run: |
        curl -L -o imagebuilder.tar.zst https://github.com/Kwonelee/iStoreOS-Actions/releases/download/iStoreOS-ImageBuilder-20251017/istoreos-imagebuilder-armsr-armv8.Linux-x86_64.tar.zst
        tar --use-compress-program=unzstd -xvf imagebuilder.tar.zst
        mv istoreos-imagebuilder-* imagebuilder

    - name: ⏬ 复制并设置必备文件
      run: |
        cp arm64/{build24.sh,Makefile} imagebuilder/
        #cp arm64/repositories.conf imagebuilder/
        cp shell/{prepare-packages.sh,custom-packages.sh} imagebuilder/
        find files/packages/ -name "*.ipk" -exec cp {} imagebuilder/packages/ \;
        
        mkdir -p imagebuilder/files/etc/{uci-defaults,opkg,banner1}
        #添加开机启动脚本
        cp files/etc/uci-defaults/99-custom.sh imagebuilder/files/etc/uci-defaults/
        #替换O大打包脚本的默认banner
        cp files/etc/banner imagebuilder/files/etc/banner1/
        mkdir -p imagebuilder/files/etc/openclash/core
        cp files/etc/openclash/core/clash_meta imagebuilder/files/etc/openclash/core/
        #临时解决通过晶晨宝盒写入emmc后根分区变为只读状态问题
        cp files/etc/rc.local imagebuilder/files/etc/
        
        cd imagebuilder
        echo "启用rootfs.tar.gz配置并停用非必要配置"
        sed -i 's/# CONFIG_TARGET_ROOTFS_TARGZ is not set/CONFIG_TARGET_ROOTFS_TARGZ=y/' .config
        sed -i "s|CONFIG_TARGET_ROOTFS_SQUASHFS=.*|# CONFIG_TARGET_ROOTFS_SQUASHFS is not set|g" .config
        sed -i "s|CONFIG_TARGET_IMAGES_GZIP=.*|# CONFIG_TARGET_IMAGES_GZIP is not set|g" .config
        echo "打印action目录结构"
        tree -L 1

    - name: ➕ 集成 OpenWrt-nikki 套件庫
      if: ${{ inputs.include_nikki == 'yes' }} 
      working-directory: ./imagebuilder
      run: |
        # 設置變數
        NIKKI_TAG="v1.24.2"
        # 由於 OECT/RK3566 屬於 ARMv8 (aarch64)，且 iStoreOS 常基於 OpenWrt 23.05+
        ARCH_OWRT="aarch64_cortex-a53-openwrt-23.05"
        FILENAME="nikki_${ARCH_OWRT}.tar.gz"
        DOWNLOAD_URL="https://github.com/nikkinikki-org/OpenWrt-nikki/releases/download/${NIKKI_TAG}/${FILENAME}"
        PACKAGE_DIR="packages" # ImageBuilder 會在這個目錄尋找 .ipk 文件

        echo "正在從 ${DOWNLOAD_URL} 下載 Nikki 插件包..."
        
        # 1. 下載對應架構的預編譯套件包 (包含所有 .ipk 文件)
        curl -L ${DOWNLOAD_URL} -o ${FILENAME}

        # 檢查下載是否成功
        if [ $? -ne 0 ] || [ ! -s "${FILENAME}" ]; then
          echo "❌ 下載 Nikki 插件包失敗，請檢查 URL 或文件是否為空。"
          exit 1
        fi

        # 2. 解壓套件到 ImageBuilder 的 packages 目錄
        mkdir -p ${PACKAGE_DIR}
        tar -xzf ${FILENAME} -C ${PACKAGE_DIR}
        rm ${FILENAME}
        
        echo "✅ Nikki 插件包已成功下載並解壓至 ${PACKAGE_DIR}"
        
        # 3. 透過修改 .config 檔案來「選中」所需插件
        # 這些配置項會讓 ImageBuilder 知道要從 packages 目錄中選中它們
        echo "CONFIG_PACKAGE_nikki=y" >> .config
        echo "CONFIG_PACKAGE_luci-app-nikki=y" >> .config
        echo "CONFIG_PACKAGE_luci-i18n-nikki-zh-cn=y" >> .config
        
        # 4. 選中常見必要依賴 (確保基礎套件存在)
        echo "CONFIG_PACKAGE_ip-full=y" >> .config
        echo "CONFIG_PACKAGE_curl=y" >> .config
        echo "CONFIG_PACKAGE_yq=y" >> .config

        echo "✅ Nikki 套件已添加到配置清單中"

    - name: ➕ 集成 OpenClash 插件
      # ⚠️ 判斷邏輯：只有在選擇 OpenClash 且沒選 Nikki 時才執行
      if: ${{ inputs.include_openclash == 'yes' && inputs.include_nikki == 'no' }} 
      working-directory: ./imagebuilder
      run: |
        OPENCLASH_REPO="vernesong/OpenClash"
        
        # 1. 查詢最新的 Release Tag (例如 v0.47.010)
        OPENCLASH_TAG=$(curl -s "https://api.github.com/repos/${OPENCLASH_REPO}/releases/latest" | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/')
        
        # 從 Tag 中提取版本號，移除開頭的 'v'
        VERSION_NUMBER=${OPENCLASH_TAG#v}

        # 2. 構建精確的 IPK 文件名和下載 URL
        IPK_FILENAME="luci-app-openclash_${VERSION_NUMBER}_all.ipk"
        DOWNLOAD_URL="https://github.com/vernesong/OpenClash/releases/download/${OPENCLASH_TAG}/${IPK_FILENAME}"
        
        echo "最新版本 OpenClash Tag: ${OPENCLASH_TAG}"
        echo "正在下載 OpenClash IPK: ${DOWNLOAD_URL}"
        
        # 3. 下載 IPK 文件
        curl -L "${DOWNLOAD_URL}" -o "${IPK_FILENAME}"

        # 4. 檢查下載是否成功
        if [ $? -ne 0 ] || [ ! -s "${IPK_FILENAME}" ]; then
          echo "❌ OpenClash IPK 下載失敗，請檢查文件名：${IPK_FILENAME} 或 Release URL。"
          exit 1
        fi

        # 5. 複製 IPK 到 ImageBuilder 的 packages 目錄
        cp "${IPK_FILENAME}" ./packages/
        rm "${IPK_FILENAME}"
        
        echo "✅ OpenClash IPK 已成功複製到 packages 目錄"
        
        # 6. 選中所需插件到配置
        echo "CONFIG_PACKAGE_luci-app-openclash=y" >> .config
        
        echo "✅ OpenClash 套件已集成"
    
    - name: 🧱 构建iStoreOS-rootfs
      working-directory: ./imagebuilder
      run: |
        echo "打印imagebuilder目录结构"
        tree -L 1
        echo "打印repositories"
        cat repositories.conf
        echo "打印Makefile"
        cat Makefile |grep here
        bash ./build24.sh

    - name: 📦 打印产出rootfs
      run: |
        echo "打印bin目录"
        ls -lah imagebuilder/bin/targets/armsr/armv8/

    - name: ⬆️ 上傳 Rootfs 到工作流產物 (Artifact)
      uses: actions/upload-artifact@v4
      with:
        name: iStoreOS-Rootfs-Base-${{ env.VERSION }}-${{ inputs.network_settings }}
        path: imagebuilder/bin/targets/armsr/armv8/*generic-rootfs.tar.gz

    - name: 🚀 上传到 Release
      uses: softprops/action-gh-release@v2.2.1
      with:
        tag_name: iStoreOS-${{ env.VERSION }}-RELEASE-${{ inputs.network_settings }}
        body: |
          📌 版本： iStoreOS-${{ env.VERSION }}-RELEASE（imagebuilder构建，稳定版）
          
          📂 来源： https://fw.koolcenter.com/iStoreOS/ib/armsr/
          
          🧠 内核： Please Login to iStoreOS → System → Amlogic Service → Replace the Kernel
          
          🧩 集成： 包含了基础系统组件、驱动、网络工具、容器支持、LuCI界面及插件等。与官方集成列表基本一致
          
          👤 用户名： root
          
          🔒 密码： 无
          
          🌐 IP： ${{ inputs.network_settings == 'static' && inputs.ipaddr || '单网口-动态获取（从上级路由找寻）；多网口-IP：192.168.100.1' }}
        files: |
          imagebuilder/bin/targets/armsr/armv8/*generic-rootfs.tar.gz
      env:
          GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}
